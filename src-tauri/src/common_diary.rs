// Generated by Molecule 0.9.0

use molecule::prelude::*;
#[derive(Clone)]
pub struct AuthorName(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AuthorName {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AuthorName {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AuthorName {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for AuthorName {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        AuthorName::new_unchecked(v)
    }
}
impl AuthorName {
    const DEFAULT_VALUE: [u8; 18] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 18;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 18;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> AuthorNameReader<'r> {
        AuthorNameReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AuthorName {
    type Builder = AuthorNameBuilder;
    const NAME: &'static str = "AuthorName";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AuthorName(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AuthorNameReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AuthorNameReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct AuthorNameReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AuthorNameReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AuthorNameReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AuthorNameReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> AuthorNameReader<'r> {
    pub const TOTAL_SIZE: usize = 18;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 18;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for AuthorNameReader<'r> {
    type Entity = AuthorName;
    const NAME: &'static str = "AuthorNameReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AuthorNameReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct AuthorNameBuilder(pub(crate) [Byte; 18]);
impl ::core::fmt::Debug for AuthorNameBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for AuthorNameBuilder {
    fn default() -> Self {
        AuthorNameBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl AuthorNameBuilder {
    pub const TOTAL_SIZE: usize = 18;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 18;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 18]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
    pub fn nth4<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[4] = v.into();
        self
    }
    pub fn nth5<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[5] = v.into();
        self
    }
    pub fn nth6<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[6] = v.into();
        self
    }
    pub fn nth7<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[7] = v.into();
        self
    }
    pub fn nth8<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[8] = v.into();
        self
    }
    pub fn nth9<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[9] = v.into();
        self
    }
    pub fn nth10<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[10] = v.into();
        self
    }
    pub fn nth11<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[11] = v.into();
        self
    }
    pub fn nth12<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[12] = v.into();
        self
    }
    pub fn nth13<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[13] = v.into();
        self
    }
    pub fn nth14<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[14] = v.into();
        self
    }
    pub fn nth15<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[15] = v.into();
        self
    }
    pub fn nth16<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[16] = v.into();
        self
    }
    pub fn nth17<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[17] = v.into();
        self
    }
}
impl molecule::prelude::Builder for AuthorNameBuilder {
    type Entity = AuthorName;
    const NAME: &'static str = "AuthorNameBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AuthorName::new_unchecked(inner.into())
    }
}
impl From<[Byte; 18usize]> for AuthorName {
    fn from(value: [Byte; 18usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for AuthorName {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 18usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<AuthorName> for [Byte; 18usize] {
    #[track_caller]
    fn from(value: AuthorName) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
        ]
    }
}
impl From<[u8; 18usize]> for AuthorName {
    fn from(value: [u8; 18usize]) -> Self {
        AuthorNameReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for AuthorName {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 18usize]>::try_from(value)?.into())
    }
}
impl From<AuthorName> for [u8; 18usize] {
    #[track_caller]
    fn from(value: AuthorName) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<AuthorNameReader<'a>> for &'a [u8; 18usize] {
    #[track_caller]
    fn from(value: AuthorNameReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a AuthorNameReader<'a>> for &'a [u8; 18usize] {
    #[track_caller]
    fn from(value: &'a AuthorNameReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct ShortTitle(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ShortTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ShortTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ShortTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for ShortTitle {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ShortTitle::new_unchecked(v)
    }
}
impl ShortTitle {
    const DEFAULT_VALUE: [u8; 30] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 30;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 30;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> ShortTitleReader<'r> {
        ShortTitleReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ShortTitle {
    type Builder = ShortTitleBuilder;
    const NAME: &'static str = "ShortTitle";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ShortTitle(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShortTitleReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShortTitleReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct ShortTitleReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ShortTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ShortTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ShortTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> ShortTitleReader<'r> {
    pub const TOTAL_SIZE: usize = 30;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 30;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for ShortTitleReader<'r> {
    type Entity = ShortTitle;
    const NAME: &'static str = "ShortTitleReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ShortTitleReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct ShortTitleBuilder(pub(crate) [Byte; 30]);
impl ::core::fmt::Debug for ShortTitleBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for ShortTitleBuilder {
    fn default() -> Self {
        ShortTitleBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl ShortTitleBuilder {
    pub const TOTAL_SIZE: usize = 30;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 30;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 30]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
    pub fn nth4<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[4] = v.into();
        self
    }
    pub fn nth5<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[5] = v.into();
        self
    }
    pub fn nth6<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[6] = v.into();
        self
    }
    pub fn nth7<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[7] = v.into();
        self
    }
    pub fn nth8<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[8] = v.into();
        self
    }
    pub fn nth9<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[9] = v.into();
        self
    }
    pub fn nth10<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[10] = v.into();
        self
    }
    pub fn nth11<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[11] = v.into();
        self
    }
    pub fn nth12<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[12] = v.into();
        self
    }
    pub fn nth13<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[13] = v.into();
        self
    }
    pub fn nth14<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[14] = v.into();
        self
    }
    pub fn nth15<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[15] = v.into();
        self
    }
    pub fn nth16<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[16] = v.into();
        self
    }
    pub fn nth17<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[17] = v.into();
        self
    }
    pub fn nth18<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[18] = v.into();
        self
    }
    pub fn nth19<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[19] = v.into();
        self
    }
    pub fn nth20<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[20] = v.into();
        self
    }
    pub fn nth21<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[21] = v.into();
        self
    }
    pub fn nth22<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[22] = v.into();
        self
    }
    pub fn nth23<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[23] = v.into();
        self
    }
    pub fn nth24<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[24] = v.into();
        self
    }
    pub fn nth25<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[25] = v.into();
        self
    }
    pub fn nth26<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[26] = v.into();
        self
    }
    pub fn nth27<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[27] = v.into();
        self
    }
    pub fn nth28<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[28] = v.into();
        self
    }
    pub fn nth29<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[29] = v.into();
        self
    }
}
impl molecule::prelude::Builder for ShortTitleBuilder {
    type Entity = ShortTitle;
    const NAME: &'static str = "ShortTitleBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ShortTitle::new_unchecked(inner.into())
    }
}
impl From<[Byte; 30usize]> for ShortTitle {
    fn from(value: [Byte; 30usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for ShortTitle {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 30usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<ShortTitle> for [Byte; 30usize] {
    #[track_caller]
    fn from(value: ShortTitle) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
            value.nth24(),
            value.nth25(),
            value.nth26(),
            value.nth27(),
            value.nth28(),
            value.nth29(),
        ]
    }
}
impl From<[u8; 30usize]> for ShortTitle {
    fn from(value: [u8; 30usize]) -> Self {
        ShortTitleReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for ShortTitle {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 30usize]>::try_from(value)?.into())
    }
}
impl From<ShortTitle> for [u8; 30usize] {
    #[track_caller]
    fn from(value: ShortTitle) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<ShortTitleReader<'a>> for &'a [u8; 30usize] {
    #[track_caller]
    fn from(value: ShortTitleReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a ShortTitleReader<'a>> for &'a [u8; 30usize] {
    #[track_caller]
    fn from(value: &'a ShortTitleReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct MediumTitle(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MediumTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MediumTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MediumTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for MediumTitle {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MediumTitle::new_unchecked(v)
    }
}
impl MediumTitle {
    const DEFAULT_VALUE: [u8; 60] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 60;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 60;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn nth45(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(45..46))
    }
    pub fn nth46(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(46..47))
    }
    pub fn nth47(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(47..48))
    }
    pub fn nth48(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(48..49))
    }
    pub fn nth49(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(49..50))
    }
    pub fn nth50(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(50..51))
    }
    pub fn nth51(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(51..52))
    }
    pub fn nth52(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(52..53))
    }
    pub fn nth53(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(53..54))
    }
    pub fn nth54(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(54..55))
    }
    pub fn nth55(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(55..56))
    }
    pub fn nth56(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(56..57))
    }
    pub fn nth57(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(57..58))
    }
    pub fn nth58(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(58..59))
    }
    pub fn nth59(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(59..60))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> MediumTitleReader<'r> {
        MediumTitleReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MediumTitle {
    type Builder = MediumTitleBuilder;
    const NAME: &'static str = "MediumTitle";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MediumTitle(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MediumTitleReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MediumTitleReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
            self.nth48(),
            self.nth49(),
            self.nth50(),
            self.nth51(),
            self.nth52(),
            self.nth53(),
            self.nth54(),
            self.nth55(),
            self.nth56(),
            self.nth57(),
            self.nth58(),
            self.nth59(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct MediumTitleReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MediumTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MediumTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MediumTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> MediumTitleReader<'r> {
    pub const TOTAL_SIZE: usize = 60;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 60;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn nth45(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[45..46])
    }
    pub fn nth46(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[46..47])
    }
    pub fn nth47(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[47..48])
    }
    pub fn nth48(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[48..49])
    }
    pub fn nth49(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[49..50])
    }
    pub fn nth50(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[50..51])
    }
    pub fn nth51(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[51..52])
    }
    pub fn nth52(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[52..53])
    }
    pub fn nth53(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[53..54])
    }
    pub fn nth54(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[54..55])
    }
    pub fn nth55(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[55..56])
    }
    pub fn nth56(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[56..57])
    }
    pub fn nth57(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[57..58])
    }
    pub fn nth58(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[58..59])
    }
    pub fn nth59(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[59..60])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for MediumTitleReader<'r> {
    type Entity = MediumTitle;
    const NAME: &'static str = "MediumTitleReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MediumTitleReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct MediumTitleBuilder(pub(crate) [Byte; 60]);
impl ::core::fmt::Debug for MediumTitleBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for MediumTitleBuilder {
    fn default() -> Self {
        MediumTitleBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl MediumTitleBuilder {
    pub const TOTAL_SIZE: usize = 60;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 60;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 60]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
    pub fn nth4<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[4] = v.into();
        self
    }
    pub fn nth5<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[5] = v.into();
        self
    }
    pub fn nth6<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[6] = v.into();
        self
    }
    pub fn nth7<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[7] = v.into();
        self
    }
    pub fn nth8<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[8] = v.into();
        self
    }
    pub fn nth9<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[9] = v.into();
        self
    }
    pub fn nth10<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[10] = v.into();
        self
    }
    pub fn nth11<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[11] = v.into();
        self
    }
    pub fn nth12<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[12] = v.into();
        self
    }
    pub fn nth13<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[13] = v.into();
        self
    }
    pub fn nth14<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[14] = v.into();
        self
    }
    pub fn nth15<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[15] = v.into();
        self
    }
    pub fn nth16<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[16] = v.into();
        self
    }
    pub fn nth17<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[17] = v.into();
        self
    }
    pub fn nth18<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[18] = v.into();
        self
    }
    pub fn nth19<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[19] = v.into();
        self
    }
    pub fn nth20<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[20] = v.into();
        self
    }
    pub fn nth21<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[21] = v.into();
        self
    }
    pub fn nth22<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[22] = v.into();
        self
    }
    pub fn nth23<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[23] = v.into();
        self
    }
    pub fn nth24<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[24] = v.into();
        self
    }
    pub fn nth25<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[25] = v.into();
        self
    }
    pub fn nth26<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[26] = v.into();
        self
    }
    pub fn nth27<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[27] = v.into();
        self
    }
    pub fn nth28<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[28] = v.into();
        self
    }
    pub fn nth29<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[29] = v.into();
        self
    }
    pub fn nth30<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[30] = v.into();
        self
    }
    pub fn nth31<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[31] = v.into();
        self
    }
    pub fn nth32<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[32] = v.into();
        self
    }
    pub fn nth33<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[33] = v.into();
        self
    }
    pub fn nth34<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[34] = v.into();
        self
    }
    pub fn nth35<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[35] = v.into();
        self
    }
    pub fn nth36<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[36] = v.into();
        self
    }
    pub fn nth37<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[37] = v.into();
        self
    }
    pub fn nth38<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[38] = v.into();
        self
    }
    pub fn nth39<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[39] = v.into();
        self
    }
    pub fn nth40<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[40] = v.into();
        self
    }
    pub fn nth41<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[41] = v.into();
        self
    }
    pub fn nth42<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[42] = v.into();
        self
    }
    pub fn nth43<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[43] = v.into();
        self
    }
    pub fn nth44<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[44] = v.into();
        self
    }
    pub fn nth45<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[45] = v.into();
        self
    }
    pub fn nth46<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[46] = v.into();
        self
    }
    pub fn nth47<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[47] = v.into();
        self
    }
    pub fn nth48<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[48] = v.into();
        self
    }
    pub fn nth49<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[49] = v.into();
        self
    }
    pub fn nth50<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[50] = v.into();
        self
    }
    pub fn nth51<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[51] = v.into();
        self
    }
    pub fn nth52<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[52] = v.into();
        self
    }
    pub fn nth53<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[53] = v.into();
        self
    }
    pub fn nth54<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[54] = v.into();
        self
    }
    pub fn nth55<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[55] = v.into();
        self
    }
    pub fn nth56<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[56] = v.into();
        self
    }
    pub fn nth57<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[57] = v.into();
        self
    }
    pub fn nth58<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[58] = v.into();
        self
    }
    pub fn nth59<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[59] = v.into();
        self
    }
}
impl molecule::prelude::Builder for MediumTitleBuilder {
    type Entity = MediumTitle;
    const NAME: &'static str = "MediumTitleBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        writer.write_all(self.0[48].as_slice())?;
        writer.write_all(self.0[49].as_slice())?;
        writer.write_all(self.0[50].as_slice())?;
        writer.write_all(self.0[51].as_slice())?;
        writer.write_all(self.0[52].as_slice())?;
        writer.write_all(self.0[53].as_slice())?;
        writer.write_all(self.0[54].as_slice())?;
        writer.write_all(self.0[55].as_slice())?;
        writer.write_all(self.0[56].as_slice())?;
        writer.write_all(self.0[57].as_slice())?;
        writer.write_all(self.0[58].as_slice())?;
        writer.write_all(self.0[59].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MediumTitle::new_unchecked(inner.into())
    }
}
impl From<[Byte; 60usize]> for MediumTitle {
    fn from(value: [Byte; 60usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for MediumTitle {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 60usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<MediumTitle> for [Byte; 60usize] {
    #[track_caller]
    fn from(value: MediumTitle) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
            value.nth24(),
            value.nth25(),
            value.nth26(),
            value.nth27(),
            value.nth28(),
            value.nth29(),
            value.nth30(),
            value.nth31(),
            value.nth32(),
            value.nth33(),
            value.nth34(),
            value.nth35(),
            value.nth36(),
            value.nth37(),
            value.nth38(),
            value.nth39(),
            value.nth40(),
            value.nth41(),
            value.nth42(),
            value.nth43(),
            value.nth44(),
            value.nth45(),
            value.nth46(),
            value.nth47(),
            value.nth48(),
            value.nth49(),
            value.nth50(),
            value.nth51(),
            value.nth52(),
            value.nth53(),
            value.nth54(),
            value.nth55(),
            value.nth56(),
            value.nth57(),
            value.nth58(),
            value.nth59(),
        ]
    }
}
impl From<[u8; 60usize]> for MediumTitle {
    fn from(value: [u8; 60usize]) -> Self {
        MediumTitleReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for MediumTitle {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 60usize]>::try_from(value)?.into())
    }
}
impl From<MediumTitle> for [u8; 60usize] {
    #[track_caller]
    fn from(value: MediumTitle) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<MediumTitleReader<'a>> for &'a [u8; 60usize] {
    #[track_caller]
    fn from(value: MediumTitleReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a MediumTitleReader<'a>> for &'a [u8; 60usize] {
    #[track_caller]
    fn from(value: &'a MediumTitleReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct LongTitle(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LongTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LongTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LongTitle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for LongTitle {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        LongTitle::new_unchecked(v)
    }
}
impl LongTitle {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> LongTitleReader<'r> {
        LongTitleReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LongTitle {
    type Builder = LongTitleBuilder;
    const NAME: &'static str = "LongTitle";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LongTitle(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongTitleReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongTitleReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct LongTitleReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LongTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LongTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LongTitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> LongTitleReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for LongTitleReader<'r> {
    type Entity = LongTitle;
    const NAME: &'static str = "LongTitleReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LongTitleReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct LongTitleBuilder(pub(crate) Vec<Byte>);
impl LongTitleBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0.push(v.into());
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        self.0.extend(iter);
        self
    }
    pub fn replace<T>(&mut self, index: usize, v: T) -> Option<Byte>
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v.into()))
    }
}
impl molecule::prelude::Builder for LongTitleBuilder {
    type Entity = LongTitle;
    const NAME: &'static str = "LongTitleBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LongTitle::new_unchecked(inner.into())
    }
}
pub struct LongTitleIterator(LongTitle, usize, usize);
impl ::core::iter::Iterator for LongTitleIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for LongTitleIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for LongTitle {
    type Item = Byte;
    type IntoIter = LongTitleIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        LongTitleIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for LongTitle {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl From<Vec<Byte>> for LongTitle {
    fn from(v: Vec<Byte>) -> Self {
        Self::new_builder().set(v).build()
    }
}
impl ::core::iter::FromIterator<u8> for LongTitle {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
impl From<Vec<u8>> for LongTitle {
    fn from(v: Vec<u8>) -> Self {
        Self::new_builder()
            .set(v.into_iter().map(Into::into).collect())
            .build()
    }
}
#[derive(Clone)]
pub struct Title(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Title {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Title {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Title {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Title {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Title::new_unchecked(v)
    }
}
impl Title {
    const DEFAULT_VALUE: [u8; 34] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TitleUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => ShortTitle::new_unchecked(inner).into(),
            1 => MediumTitle::new_unchecked(inner).into(),
            2 => LongTitle::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> TitleReader<'r> {
        TitleReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Title {
    type Builder = TitleBuilder;
    const NAME: &'static str = "Title";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Title(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TitleReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TitleReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct TitleReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TitleReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> TitleReader<'r> {
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TitleUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ShortTitleReader::new_unchecked(inner).into(),
            1 => MediumTitleReader::new_unchecked(inner).into(),
            2 => LongTitleReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TitleReader<'r> {
    type Entity = Title;
    const NAME: &'static str = "TitleReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TitleReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ShortTitleReader::verify(inner_slice, compatible),
            1 => MediumTitleReader::verify(inner_slice, compatible),
            2 => LongTitleReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TitleBuilder(pub(crate) TitleUnion);
impl TitleBuilder {
    pub const ITEMS_COUNT: usize = 3;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<TitleUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for TitleBuilder {
    type Entity = Title;
    const NAME: &'static str = "TitleBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Title::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum TitleUnion {
    ShortTitle(ShortTitle),
    MediumTitle(MediumTitle),
    LongTitle(LongTitle),
}
#[derive(Debug, Clone, Copy)]
pub enum TitleUnionReader<'r> {
    ShortTitle(ShortTitleReader<'r>),
    MediumTitle(MediumTitleReader<'r>),
    LongTitle(LongTitleReader<'r>),
}
impl ::core::default::Default for TitleUnion {
    fn default() -> Self {
        TitleUnion::ShortTitle(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for TitleUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TitleUnion::ShortTitle(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ShortTitle::NAME, item)
            }
            TitleUnion::MediumTitle(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MediumTitle::NAME, item)
            }
            TitleUnion::LongTitle(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongTitle::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for TitleUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TitleUnionReader::ShortTitle(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ShortTitle::NAME, item)
            }
            TitleUnionReader::MediumTitle(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, MediumTitle::NAME, item)
            }
            TitleUnionReader::LongTitle(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongTitle::NAME, item)
            }
        }
    }
}
impl TitleUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TitleUnion::ShortTitle(ref item) => write!(f, "{}", item),
            TitleUnion::MediumTitle(ref item) => write!(f, "{}", item),
            TitleUnion::LongTitle(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> TitleUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TitleUnionReader::ShortTitle(ref item) => write!(f, "{}", item),
            TitleUnionReader::MediumTitle(ref item) => write!(f, "{}", item),
            TitleUnionReader::LongTitle(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<ShortTitle> for TitleUnion {
    fn from(item: ShortTitle) -> Self {
        TitleUnion::ShortTitle(item)
    }
}
impl ::core::convert::From<MediumTitle> for TitleUnion {
    fn from(item: MediumTitle) -> Self {
        TitleUnion::MediumTitle(item)
    }
}
impl ::core::convert::From<LongTitle> for TitleUnion {
    fn from(item: LongTitle) -> Self {
        TitleUnion::LongTitle(item)
    }
}
impl<'r> ::core::convert::From<ShortTitleReader<'r>> for TitleUnionReader<'r> {
    fn from(item: ShortTitleReader<'r>) -> Self {
        TitleUnionReader::ShortTitle(item)
    }
}
impl<'r> ::core::convert::From<MediumTitleReader<'r>> for TitleUnionReader<'r> {
    fn from(item: MediumTitleReader<'r>) -> Self {
        TitleUnionReader::MediumTitle(item)
    }
}
impl<'r> ::core::convert::From<LongTitleReader<'r>> for TitleUnionReader<'r> {
    fn from(item: LongTitleReader<'r>) -> Self {
        TitleUnionReader::LongTitle(item)
    }
}
impl TitleUnion {
    pub const NAME: &'static str = "TitleUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            TitleUnion::ShortTitle(item) => item.as_bytes(),
            TitleUnion::MediumTitle(item) => item.as_bytes(),
            TitleUnion::LongTitle(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            TitleUnion::ShortTitle(item) => item.as_slice(),
            TitleUnion::MediumTitle(item) => item.as_slice(),
            TitleUnion::LongTitle(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TitleUnion::ShortTitle(_) => 0,
            TitleUnion::MediumTitle(_) => 1,
            TitleUnion::LongTitle(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TitleUnion::ShortTitle(_) => "ShortTitle",
            TitleUnion::MediumTitle(_) => "MediumTitle",
            TitleUnion::LongTitle(_) => "LongTitle",
        }
    }
    pub fn as_reader<'r>(&'r self) -> TitleUnionReader<'r> {
        match self {
            TitleUnion::ShortTitle(item) => item.as_reader().into(),
            TitleUnion::MediumTitle(item) => item.as_reader().into(),
            TitleUnion::LongTitle(item) => item.as_reader().into(),
        }
    }
}
impl<'r> TitleUnionReader<'r> {
    pub const NAME: &'r str = "TitleUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            TitleUnionReader::ShortTitle(item) => item.as_slice(),
            TitleUnionReader::MediumTitle(item) => item.as_slice(),
            TitleUnionReader::LongTitle(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TitleUnionReader::ShortTitle(_) => 0,
            TitleUnionReader::MediumTitle(_) => 1,
            TitleUnionReader::LongTitle(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TitleUnionReader::ShortTitle(_) => "ShortTitle",
            TitleUnionReader::MediumTitle(_) => "MediumTitle",
            TitleUnionReader::LongTitle(_) => "LongTitle",
        }
    }
}
impl From<ShortTitle> for Title {
    fn from(value: ShortTitle) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<MediumTitle> for Title {
    fn from(value: MediumTitle) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<LongTitle> for Title {
    fn from(value: LongTitle) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct TitleOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TitleOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TitleOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TitleOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for TitleOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TitleOpt::new_unchecked(v)
    }
}
impl TitleOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Title> {
        if self.is_none() {
            None
        } else {
            Some(Title::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TitleOptReader<'r> {
        TitleOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TitleOpt {
    type Builder = TitleOptBuilder;
    const NAME: &'static str = "TitleOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TitleOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TitleOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TitleOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct TitleOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TitleOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TitleOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TitleOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> TitleOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<TitleReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(TitleReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TitleOptReader<'r> {
    type Entity = TitleOpt;
    const NAME: &'static str = "TitleOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TitleOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            TitleReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TitleOptBuilder(pub(crate) Option<Title>);
impl TitleOptBuilder {
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Option<Title>>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for TitleOptBuilder {
    type Entity = TitleOpt;
    const NAME: &'static str = "TitleOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TitleOpt::new_unchecked(inner.into())
    }
}
impl From<Title> for TitleOpt {
    fn from(value: Title) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct ShortDateRaw(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ShortDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ShortDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ShortDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for ShortDateRaw {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ShortDateRaw::new_unchecked(v)
    }
}
impl ShortDateRaw {
    const DEFAULT_VALUE: [u8; 24] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 24;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 24;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> ShortDateRawReader<'r> {
        ShortDateRawReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ShortDateRaw {
    type Builder = ShortDateRawBuilder;
    const NAME: &'static str = "ShortDateRaw";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ShortDateRaw(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShortDateRawReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShortDateRawReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct ShortDateRawReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ShortDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ShortDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ShortDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> ShortDateRawReader<'r> {
    pub const TOTAL_SIZE: usize = 24;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 24;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for ShortDateRawReader<'r> {
    type Entity = ShortDateRaw;
    const NAME: &'static str = "ShortDateRawReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ShortDateRawReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct ShortDateRawBuilder(pub(crate) [Byte; 24]);
impl ::core::fmt::Debug for ShortDateRawBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for ShortDateRawBuilder {
    fn default() -> Self {
        ShortDateRawBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl ShortDateRawBuilder {
    pub const TOTAL_SIZE: usize = 24;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 24;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 24]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
    pub fn nth4<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[4] = v.into();
        self
    }
    pub fn nth5<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[5] = v.into();
        self
    }
    pub fn nth6<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[6] = v.into();
        self
    }
    pub fn nth7<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[7] = v.into();
        self
    }
    pub fn nth8<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[8] = v.into();
        self
    }
    pub fn nth9<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[9] = v.into();
        self
    }
    pub fn nth10<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[10] = v.into();
        self
    }
    pub fn nth11<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[11] = v.into();
        self
    }
    pub fn nth12<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[12] = v.into();
        self
    }
    pub fn nth13<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[13] = v.into();
        self
    }
    pub fn nth14<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[14] = v.into();
        self
    }
    pub fn nth15<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[15] = v.into();
        self
    }
    pub fn nth16<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[16] = v.into();
        self
    }
    pub fn nth17<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[17] = v.into();
        self
    }
    pub fn nth18<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[18] = v.into();
        self
    }
    pub fn nth19<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[19] = v.into();
        self
    }
    pub fn nth20<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[20] = v.into();
        self
    }
    pub fn nth21<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[21] = v.into();
        self
    }
    pub fn nth22<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[22] = v.into();
        self
    }
    pub fn nth23<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[23] = v.into();
        self
    }
}
impl molecule::prelude::Builder for ShortDateRawBuilder {
    type Entity = ShortDateRaw;
    const NAME: &'static str = "ShortDateRawBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ShortDateRaw::new_unchecked(inner.into())
    }
}
impl From<[Byte; 24usize]> for ShortDateRaw {
    fn from(value: [Byte; 24usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for ShortDateRaw {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 24usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<ShortDateRaw> for [Byte; 24usize] {
    #[track_caller]
    fn from(value: ShortDateRaw) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
        ]
    }
}
impl From<[u8; 24usize]> for ShortDateRaw {
    fn from(value: [u8; 24usize]) -> Self {
        ShortDateRawReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for ShortDateRaw {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 24usize]>::try_from(value)?.into())
    }
}
impl From<ShortDateRaw> for [u8; 24usize] {
    #[track_caller]
    fn from(value: ShortDateRaw) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<ShortDateRawReader<'a>> for &'a [u8; 24usize] {
    #[track_caller]
    fn from(value: ShortDateRawReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a ShortDateRawReader<'a>> for &'a [u8; 24usize] {
    #[track_caller]
    fn from(value: &'a ShortDateRawReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct LongDateRaw(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LongDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LongDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LongDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for LongDateRaw {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        LongDateRaw::new_unchecked(v)
    }
}
impl LongDateRaw {
    const DEFAULT_VALUE: [u8; 48] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 48;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 48;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn nth45(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(45..46))
    }
    pub fn nth46(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(46..47))
    }
    pub fn nth47(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(47..48))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> LongDateRawReader<'r> {
        LongDateRawReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LongDateRaw {
    type Builder = LongDateRawBuilder;
    const NAME: &'static str = "LongDateRaw";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LongDateRaw(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongDateRawReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongDateRawReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct LongDateRawReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LongDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LongDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LongDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> LongDateRawReader<'r> {
    pub const TOTAL_SIZE: usize = 48;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 48;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn nth45(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[45..46])
    }
    pub fn nth46(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[46..47])
    }
    pub fn nth47(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[47..48])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for LongDateRawReader<'r> {
    type Entity = LongDateRaw;
    const NAME: &'static str = "LongDateRawReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LongDateRawReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct LongDateRawBuilder(pub(crate) [Byte; 48]);
impl ::core::fmt::Debug for LongDateRawBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for LongDateRawBuilder {
    fn default() -> Self {
        LongDateRawBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl LongDateRawBuilder {
    pub const TOTAL_SIZE: usize = 48;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 48;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 48]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
    pub fn nth4<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[4] = v.into();
        self
    }
    pub fn nth5<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[5] = v.into();
        self
    }
    pub fn nth6<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[6] = v.into();
        self
    }
    pub fn nth7<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[7] = v.into();
        self
    }
    pub fn nth8<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[8] = v.into();
        self
    }
    pub fn nth9<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[9] = v.into();
        self
    }
    pub fn nth10<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[10] = v.into();
        self
    }
    pub fn nth11<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[11] = v.into();
        self
    }
    pub fn nth12<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[12] = v.into();
        self
    }
    pub fn nth13<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[13] = v.into();
        self
    }
    pub fn nth14<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[14] = v.into();
        self
    }
    pub fn nth15<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[15] = v.into();
        self
    }
    pub fn nth16<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[16] = v.into();
        self
    }
    pub fn nth17<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[17] = v.into();
        self
    }
    pub fn nth18<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[18] = v.into();
        self
    }
    pub fn nth19<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[19] = v.into();
        self
    }
    pub fn nth20<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[20] = v.into();
        self
    }
    pub fn nth21<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[21] = v.into();
        self
    }
    pub fn nth22<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[22] = v.into();
        self
    }
    pub fn nth23<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[23] = v.into();
        self
    }
    pub fn nth24<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[24] = v.into();
        self
    }
    pub fn nth25<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[25] = v.into();
        self
    }
    pub fn nth26<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[26] = v.into();
        self
    }
    pub fn nth27<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[27] = v.into();
        self
    }
    pub fn nth28<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[28] = v.into();
        self
    }
    pub fn nth29<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[29] = v.into();
        self
    }
    pub fn nth30<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[30] = v.into();
        self
    }
    pub fn nth31<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[31] = v.into();
        self
    }
    pub fn nth32<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[32] = v.into();
        self
    }
    pub fn nth33<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[33] = v.into();
        self
    }
    pub fn nth34<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[34] = v.into();
        self
    }
    pub fn nth35<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[35] = v.into();
        self
    }
    pub fn nth36<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[36] = v.into();
        self
    }
    pub fn nth37<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[37] = v.into();
        self
    }
    pub fn nth38<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[38] = v.into();
        self
    }
    pub fn nth39<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[39] = v.into();
        self
    }
    pub fn nth40<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[40] = v.into();
        self
    }
    pub fn nth41<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[41] = v.into();
        self
    }
    pub fn nth42<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[42] = v.into();
        self
    }
    pub fn nth43<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[43] = v.into();
        self
    }
    pub fn nth44<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[44] = v.into();
        self
    }
    pub fn nth45<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[45] = v.into();
        self
    }
    pub fn nth46<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[46] = v.into();
        self
    }
    pub fn nth47<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[47] = v.into();
        self
    }
}
impl molecule::prelude::Builder for LongDateRawBuilder {
    type Entity = LongDateRaw;
    const NAME: &'static str = "LongDateRawBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LongDateRaw::new_unchecked(inner.into())
    }
}
impl From<[Byte; 48usize]> for LongDateRaw {
    fn from(value: [Byte; 48usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for LongDateRaw {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 48usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<LongDateRaw> for [Byte; 48usize] {
    #[track_caller]
    fn from(value: LongDateRaw) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
            value.nth12(),
            value.nth13(),
            value.nth14(),
            value.nth15(),
            value.nth16(),
            value.nth17(),
            value.nth18(),
            value.nth19(),
            value.nth20(),
            value.nth21(),
            value.nth22(),
            value.nth23(),
            value.nth24(),
            value.nth25(),
            value.nth26(),
            value.nth27(),
            value.nth28(),
            value.nth29(),
            value.nth30(),
            value.nth31(),
            value.nth32(),
            value.nth33(),
            value.nth34(),
            value.nth35(),
            value.nth36(),
            value.nth37(),
            value.nth38(),
            value.nth39(),
            value.nth40(),
            value.nth41(),
            value.nth42(),
            value.nth43(),
            value.nth44(),
            value.nth45(),
            value.nth46(),
            value.nth47(),
        ]
    }
}
impl From<[u8; 48usize]> for LongDateRaw {
    fn from(value: [u8; 48usize]) -> Self {
        LongDateRawReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for LongDateRaw {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 48usize]>::try_from(value)?.into())
    }
}
impl From<LongDateRaw> for [u8; 48usize] {
    #[track_caller]
    fn from(value: LongDateRaw) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<LongDateRawReader<'a>> for &'a [u8; 48usize] {
    #[track_caller]
    fn from(value: LongDateRawReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a LongDateRawReader<'a>> for &'a [u8; 48usize] {
    #[track_caller]
    fn from(value: &'a LongDateRawReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct ExtendedDateRaw(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ExtendedDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ExtendedDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ExtendedDateRaw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for ExtendedDateRaw {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ExtendedDateRaw::new_unchecked(v)
    }
}
impl ExtendedDateRaw {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> ExtendedDateRawReader<'r> {
        ExtendedDateRawReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ExtendedDateRaw {
    type Builder = ExtendedDateRawBuilder;
    const NAME: &'static str = "ExtendedDateRaw";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ExtendedDateRaw(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ExtendedDateRawReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ExtendedDateRawReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct ExtendedDateRawReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ExtendedDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ExtendedDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ExtendedDateRawReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> ExtendedDateRawReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for ExtendedDateRawReader<'r> {
    type Entity = ExtendedDateRaw;
    const NAME: &'static str = "ExtendedDateRawReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ExtendedDateRawReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ExtendedDateRawBuilder(pub(crate) Vec<Byte>);
impl ExtendedDateRawBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0.push(v.into());
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        self.0.extend(iter);
        self
    }
    pub fn replace<T>(&mut self, index: usize, v: T) -> Option<Byte>
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v.into()))
    }
}
impl molecule::prelude::Builder for ExtendedDateRawBuilder {
    type Entity = ExtendedDateRaw;
    const NAME: &'static str = "ExtendedDateRawBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ExtendedDateRaw::new_unchecked(inner.into())
    }
}
pub struct ExtendedDateRawIterator(ExtendedDateRaw, usize, usize);
impl ::core::iter::Iterator for ExtendedDateRawIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for ExtendedDateRawIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for ExtendedDateRaw {
    type Item = Byte;
    type IntoIter = ExtendedDateRawIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        ExtendedDateRawIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for ExtendedDateRaw {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl From<Vec<Byte>> for ExtendedDateRaw {
    fn from(v: Vec<Byte>) -> Self {
        Self::new_builder().set(v).build()
    }
}
impl ::core::iter::FromIterator<u8> for ExtendedDateRaw {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
impl From<Vec<u8>> for ExtendedDateRaw {
    fn from(v: Vec<u8>) -> Self {
        Self::new_builder()
            .set(v.into_iter().map(Into::into).collect())
            .build()
    }
}
#[derive(Clone)]
pub struct DateRawText(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for DateRawText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for DateRawText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for DateRawText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for DateRawText {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        DateRawText::new_unchecked(v)
    }
}
impl DateRawText {
    const DEFAULT_VALUE: [u8; 28] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> DateRawTextUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => ShortDateRaw::new_unchecked(inner).into(),
            1 => LongDateRaw::new_unchecked(inner).into(),
            2 => ExtendedDateRaw::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> DateRawTextReader<'r> {
        DateRawTextReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for DateRawText {
    type Builder = DateRawTextBuilder;
    const NAME: &'static str = "DateRawText";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DateRawText(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateRawTextReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateRawTextReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct DateRawTextReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DateRawTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DateRawTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DateRawTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> DateRawTextReader<'r> {
    pub const ITEMS_COUNT: usize = 3;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> DateRawTextUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ShortDateRawReader::new_unchecked(inner).into(),
            1 => LongDateRawReader::new_unchecked(inner).into(),
            2 => ExtendedDateRawReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DateRawTextReader<'r> {
    type Entity = DateRawText;
    const NAME: &'static str = "DateRawTextReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DateRawTextReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ShortDateRawReader::verify(inner_slice, compatible),
            1 => LongDateRawReader::verify(inner_slice, compatible),
            2 => ExtendedDateRawReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct DateRawTextBuilder(pub(crate) DateRawTextUnion);
impl DateRawTextBuilder {
    pub const ITEMS_COUNT: usize = 3;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<DateRawTextUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for DateRawTextBuilder {
    type Entity = DateRawText;
    const NAME: &'static str = "DateRawTextBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        DateRawText::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum DateRawTextUnion {
    ShortDateRaw(ShortDateRaw),
    LongDateRaw(LongDateRaw),
    ExtendedDateRaw(ExtendedDateRaw),
}
#[derive(Debug, Clone, Copy)]
pub enum DateRawTextUnionReader<'r> {
    ShortDateRaw(ShortDateRawReader<'r>),
    LongDateRaw(LongDateRawReader<'r>),
    ExtendedDateRaw(ExtendedDateRawReader<'r>),
}
impl ::core::default::Default for DateRawTextUnion {
    fn default() -> Self {
        DateRawTextUnion::ShortDateRaw(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for DateRawTextUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            DateRawTextUnion::ShortDateRaw(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ShortDateRaw::NAME, item)
            }
            DateRawTextUnion::LongDateRaw(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongDateRaw::NAME, item)
            }
            DateRawTextUnion::ExtendedDateRaw(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ExtendedDateRaw::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for DateRawTextUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            DateRawTextUnionReader::ShortDateRaw(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ShortDateRaw::NAME, item)
            }
            DateRawTextUnionReader::LongDateRaw(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongDateRaw::NAME, item)
            }
            DateRawTextUnionReader::ExtendedDateRaw(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ExtendedDateRaw::NAME, item)
            }
        }
    }
}
impl DateRawTextUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            DateRawTextUnion::ShortDateRaw(ref item) => write!(f, "{}", item),
            DateRawTextUnion::LongDateRaw(ref item) => write!(f, "{}", item),
            DateRawTextUnion::ExtendedDateRaw(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> DateRawTextUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            DateRawTextUnionReader::ShortDateRaw(ref item) => write!(f, "{}", item),
            DateRawTextUnionReader::LongDateRaw(ref item) => write!(f, "{}", item),
            DateRawTextUnionReader::ExtendedDateRaw(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<ShortDateRaw> for DateRawTextUnion {
    fn from(item: ShortDateRaw) -> Self {
        DateRawTextUnion::ShortDateRaw(item)
    }
}
impl ::core::convert::From<LongDateRaw> for DateRawTextUnion {
    fn from(item: LongDateRaw) -> Self {
        DateRawTextUnion::LongDateRaw(item)
    }
}
impl ::core::convert::From<ExtendedDateRaw> for DateRawTextUnion {
    fn from(item: ExtendedDateRaw) -> Self {
        DateRawTextUnion::ExtendedDateRaw(item)
    }
}
impl<'r> ::core::convert::From<ShortDateRawReader<'r>> for DateRawTextUnionReader<'r> {
    fn from(item: ShortDateRawReader<'r>) -> Self {
        DateRawTextUnionReader::ShortDateRaw(item)
    }
}
impl<'r> ::core::convert::From<LongDateRawReader<'r>> for DateRawTextUnionReader<'r> {
    fn from(item: LongDateRawReader<'r>) -> Self {
        DateRawTextUnionReader::LongDateRaw(item)
    }
}
impl<'r> ::core::convert::From<ExtendedDateRawReader<'r>> for DateRawTextUnionReader<'r> {
    fn from(item: ExtendedDateRawReader<'r>) -> Self {
        DateRawTextUnionReader::ExtendedDateRaw(item)
    }
}
impl DateRawTextUnion {
    pub const NAME: &'static str = "DateRawTextUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            DateRawTextUnion::ShortDateRaw(item) => item.as_bytes(),
            DateRawTextUnion::LongDateRaw(item) => item.as_bytes(),
            DateRawTextUnion::ExtendedDateRaw(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            DateRawTextUnion::ShortDateRaw(item) => item.as_slice(),
            DateRawTextUnion::LongDateRaw(item) => item.as_slice(),
            DateRawTextUnion::ExtendedDateRaw(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            DateRawTextUnion::ShortDateRaw(_) => 0,
            DateRawTextUnion::LongDateRaw(_) => 1,
            DateRawTextUnion::ExtendedDateRaw(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            DateRawTextUnion::ShortDateRaw(_) => "ShortDateRaw",
            DateRawTextUnion::LongDateRaw(_) => "LongDateRaw",
            DateRawTextUnion::ExtendedDateRaw(_) => "ExtendedDateRaw",
        }
    }
    pub fn as_reader<'r>(&'r self) -> DateRawTextUnionReader<'r> {
        match self {
            DateRawTextUnion::ShortDateRaw(item) => item.as_reader().into(),
            DateRawTextUnion::LongDateRaw(item) => item.as_reader().into(),
            DateRawTextUnion::ExtendedDateRaw(item) => item.as_reader().into(),
        }
    }
}
impl<'r> DateRawTextUnionReader<'r> {
    pub const NAME: &'r str = "DateRawTextUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            DateRawTextUnionReader::ShortDateRaw(item) => item.as_slice(),
            DateRawTextUnionReader::LongDateRaw(item) => item.as_slice(),
            DateRawTextUnionReader::ExtendedDateRaw(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            DateRawTextUnionReader::ShortDateRaw(_) => 0,
            DateRawTextUnionReader::LongDateRaw(_) => 1,
            DateRawTextUnionReader::ExtendedDateRaw(_) => 2,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            DateRawTextUnionReader::ShortDateRaw(_) => "ShortDateRaw",
            DateRawTextUnionReader::LongDateRaw(_) => "LongDateRaw",
            DateRawTextUnionReader::ExtendedDateRaw(_) => "ExtendedDateRaw",
        }
    }
}
impl From<ShortDateRaw> for DateRawText {
    fn from(value: ShortDateRaw) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<LongDateRaw> for DateRawText {
    fn from(value: LongDateRaw) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<ExtendedDateRaw> for DateRawText {
    fn from(value: ExtendedDateRaw) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct DateRawOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for DateRawOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for DateRawOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for DateRawOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for DateRawOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        DateRawOpt::new_unchecked(v)
    }
}
impl DateRawOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<DateRawText> {
        if self.is_none() {
            None
        } else {
            Some(DateRawText::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> DateRawOptReader<'r> {
        DateRawOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for DateRawOpt {
    type Builder = DateRawOptBuilder;
    const NAME: &'static str = "DateRawOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DateRawOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateRawOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateRawOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct DateRawOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DateRawOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DateRawOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DateRawOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> DateRawOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<DateRawTextReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(DateRawTextReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DateRawOptReader<'r> {
    type Entity = DateRawOpt;
    const NAME: &'static str = "DateRawOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DateRawOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            DateRawTextReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct DateRawOptBuilder(pub(crate) Option<DateRawText>);
impl DateRawOptBuilder {
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Option<DateRawText>>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for DateRawOptBuilder {
    type Entity = DateRawOpt;
    const NAME: &'static str = "DateRawOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        DateRawOpt::new_unchecked(inner.into())
    }
}
impl From<DateRawText> for DateRawOpt {
    fn from(value: DateRawText) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct DateInt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for DateInt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for DateInt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for DateInt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for DateInt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        DateInt::new_unchecked(v)
    }
}
impl DateInt {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> DateIntReader<'r> {
        DateIntReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for DateInt {
    type Builder = DateIntBuilder;
    const NAME: &'static str = "DateInt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DateInt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateIntReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DateIntReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2(), self.nth3()])
    }
}
#[derive(Clone, Copy)]
pub struct DateIntReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DateIntReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DateIntReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DateIntReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> DateIntReader<'r> {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for DateIntReader<'r> {
    type Entity = DateInt;
    const NAME: &'static str = "DateIntReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DateIntReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct DateIntBuilder(pub(crate) [Byte; 4]);
impl ::core::fmt::Debug for DateIntBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for DateIntBuilder {
    fn default() -> Self {
        DateIntBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl DateIntBuilder {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 4]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
}
impl molecule::prelude::Builder for DateIntBuilder {
    type Entity = DateInt;
    const NAME: &'static str = "DateIntBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        DateInt::new_unchecked(inner.into())
    }
}
impl From<[Byte; 4usize]> for DateInt {
    fn from(value: [Byte; 4usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for DateInt {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 4usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<DateInt> for [Byte; 4usize] {
    #[track_caller]
    fn from(value: DateInt) -> Self {
        [value.nth0(), value.nth1(), value.nth2(), value.nth3()]
    }
}
impl From<[u8; 4usize]> for DateInt {
    fn from(value: [u8; 4usize]) -> Self {
        DateIntReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for DateInt {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 4usize]>::try_from(value)?.into())
    }
}
impl From<DateInt> for [u8; 4usize] {
    #[track_caller]
    fn from(value: DateInt) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<DateIntReader<'a>> for &'a [u8; 4usize] {
    #[track_caller]
    fn from(value: DateIntReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a DateIntReader<'a>> for &'a [u8; 4usize] {
    #[track_caller]
    fn from(value: &'a DateIntReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct WeatherType(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WeatherType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WeatherType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WeatherType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for WeatherType {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WeatherType::new_unchecked(v)
    }
}
impl WeatherType {
    const DEFAULT_VALUE: [u8; 1] = [0];
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> WeatherTypeReader<'r> {
        WeatherTypeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WeatherType {
    type Builder = WeatherTypeBuilder;
    const NAME: &'static str = "WeatherType";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WeatherType(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherTypeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherTypeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct WeatherTypeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WeatherTypeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WeatherTypeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WeatherTypeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> WeatherTypeReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for WeatherTypeReader<'r> {
    type Entity = WeatherType;
    const NAME: &'static str = "WeatherTypeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WeatherTypeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct WeatherTypeBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for WeatherTypeBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for WeatherTypeBuilder {
    fn default() -> Self {
        WeatherTypeBuilder([Byte::default()])
    }
}
impl WeatherTypeBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 1]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
}
impl molecule::prelude::Builder for WeatherTypeBuilder {
    type Entity = WeatherType;
    const NAME: &'static str = "WeatherTypeBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WeatherType::new_unchecked(inner.into())
    }
}
impl From<[Byte; 1usize]> for WeatherType {
    fn from(value: [Byte; 1usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for WeatherType {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 1usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<WeatherType> for [Byte; 1usize] {
    #[track_caller]
    fn from(value: WeatherType) -> Self {
        [value.nth0()]
    }
}
impl From<[u8; 1usize]> for WeatherType {
    fn from(value: [u8; 1usize]) -> Self {
        WeatherTypeReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for WeatherType {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 1usize]>::try_from(value)?.into())
    }
}
impl From<WeatherType> for [u8; 1usize] {
    #[track_caller]
    fn from(value: WeatherType) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<WeatherTypeReader<'a>> for &'a [u8; 1usize] {
    #[track_caller]
    fn from(value: WeatherTypeReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a WeatherTypeReader<'a>> for &'a [u8; 1usize] {
    #[track_caller]
    fn from(value: &'a WeatherTypeReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct FixedWeather(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FixedWeather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FixedWeather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FixedWeather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for FixedWeather {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        FixedWeather::new_unchecked(v)
    }
}
impl FixedWeather {
    const DEFAULT_VALUE: [u8; 12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> FixedWeatherReader<'r> {
        FixedWeatherReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FixedWeather {
    type Builder = FixedWeatherBuilder;
    const NAME: &'static str = "FixedWeather";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FixedWeather(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FixedWeatherReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FixedWeatherReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct FixedWeatherReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FixedWeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FixedWeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FixedWeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> FixedWeatherReader<'r> {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for FixedWeatherReader<'r> {
    type Entity = FixedWeather;
    const NAME: &'static str = "FixedWeatherReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FixedWeatherReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct FixedWeatherBuilder(pub(crate) [Byte; 12]);
impl ::core::fmt::Debug for FixedWeatherBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for FixedWeatherBuilder {
    fn default() -> Self {
        FixedWeatherBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl FixedWeatherBuilder {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 12]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
    pub fn nth4<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[4] = v.into();
        self
    }
    pub fn nth5<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[5] = v.into();
        self
    }
    pub fn nth6<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[6] = v.into();
        self
    }
    pub fn nth7<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[7] = v.into();
        self
    }
    pub fn nth8<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[8] = v.into();
        self
    }
    pub fn nth9<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[9] = v.into();
        self
    }
    pub fn nth10<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[10] = v.into();
        self
    }
    pub fn nth11<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[11] = v.into();
        self
    }
}
impl molecule::prelude::Builder for FixedWeatherBuilder {
    type Entity = FixedWeather;
    const NAME: &'static str = "FixedWeatherBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FixedWeather::new_unchecked(inner.into())
    }
}
impl From<[Byte; 12usize]> for FixedWeather {
    fn from(value: [Byte; 12usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for FixedWeather {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 12usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<FixedWeather> for [Byte; 12usize] {
    #[track_caller]
    fn from(value: FixedWeather) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
        ]
    }
}
impl From<[u8; 12usize]> for FixedWeather {
    fn from(value: [u8; 12usize]) -> Self {
        FixedWeatherReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for FixedWeather {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 12usize]>::try_from(value)?.into())
    }
}
impl From<FixedWeather> for [u8; 12usize] {
    #[track_caller]
    fn from(value: FixedWeather) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<FixedWeatherReader<'a>> for &'a [u8; 12usize] {
    #[track_caller]
    fn from(value: FixedWeatherReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a FixedWeatherReader<'a>> for &'a [u8; 12usize] {
    #[track_caller]
    fn from(value: &'a FixedWeatherReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct LongWeather(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LongWeather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LongWeather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LongWeather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for LongWeather {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        LongWeather::new_unchecked(v)
    }
}
impl LongWeather {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> LongWeatherReader<'r> {
        LongWeatherReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LongWeather {
    type Builder = LongWeatherBuilder;
    const NAME: &'static str = "LongWeather";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LongWeather(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongWeatherReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongWeatherReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct LongWeatherReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LongWeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LongWeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LongWeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> LongWeatherReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for LongWeatherReader<'r> {
    type Entity = LongWeather;
    const NAME: &'static str = "LongWeatherReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LongWeatherReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct LongWeatherBuilder(pub(crate) Vec<Byte>);
impl LongWeatherBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0.push(v.into());
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        self.0.extend(iter);
        self
    }
    pub fn replace<T>(&mut self, index: usize, v: T) -> Option<Byte>
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v.into()))
    }
}
impl molecule::prelude::Builder for LongWeatherBuilder {
    type Entity = LongWeather;
    const NAME: &'static str = "LongWeatherBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LongWeather::new_unchecked(inner.into())
    }
}
pub struct LongWeatherIterator(LongWeather, usize, usize);
impl ::core::iter::Iterator for LongWeatherIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for LongWeatherIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for LongWeather {
    type Item = Byte;
    type IntoIter = LongWeatherIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        LongWeatherIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for LongWeather {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl From<Vec<Byte>> for LongWeather {
    fn from(v: Vec<Byte>) -> Self {
        Self::new_builder().set(v).build()
    }
}
impl ::core::iter::FromIterator<u8> for LongWeather {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
impl From<Vec<u8>> for LongWeather {
    fn from(v: Vec<u8>) -> Self {
        Self::new_builder()
            .set(v.into_iter().map(Into::into).collect())
            .build()
    }
}
#[derive(Clone)]
pub struct WeatherText(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WeatherText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WeatherText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WeatherText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for WeatherText {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WeatherText::new_unchecked(v)
    }
}
impl WeatherText {
    const DEFAULT_VALUE: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> WeatherTextUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => FixedWeather::new_unchecked(inner).into(),
            1 => LongWeather::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> WeatherTextReader<'r> {
        WeatherTextReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WeatherText {
    type Builder = WeatherTextBuilder;
    const NAME: &'static str = "WeatherText";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WeatherText(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherTextReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherTextReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct WeatherTextReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WeatherTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WeatherTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WeatherTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> WeatherTextReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> WeatherTextUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => FixedWeatherReader::new_unchecked(inner).into(),
            1 => LongWeatherReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WeatherTextReader<'r> {
    type Entity = WeatherText;
    const NAME: &'static str = "WeatherTextReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WeatherTextReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => FixedWeatherReader::verify(inner_slice, compatible),
            1 => LongWeatherReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WeatherTextBuilder(pub(crate) WeatherTextUnion);
impl WeatherTextBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<WeatherTextUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for WeatherTextBuilder {
    type Entity = WeatherText;
    const NAME: &'static str = "WeatherTextBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WeatherText::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum WeatherTextUnion {
    FixedWeather(FixedWeather),
    LongWeather(LongWeather),
}
#[derive(Debug, Clone, Copy)]
pub enum WeatherTextUnionReader<'r> {
    FixedWeather(FixedWeatherReader<'r>),
    LongWeather(LongWeatherReader<'r>),
}
impl ::core::default::Default for WeatherTextUnion {
    fn default() -> Self {
        WeatherTextUnion::FixedWeather(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for WeatherTextUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherTextUnion::FixedWeather(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FixedWeather::NAME, item)
            }
            WeatherTextUnion::LongWeather(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongWeather::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for WeatherTextUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherTextUnionReader::FixedWeather(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FixedWeather::NAME, item)
            }
            WeatherTextUnionReader::LongWeather(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongWeather::NAME, item)
            }
        }
    }
}
impl WeatherTextUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherTextUnion::FixedWeather(ref item) => write!(f, "{}", item),
            WeatherTextUnion::LongWeather(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> WeatherTextUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherTextUnionReader::FixedWeather(ref item) => write!(f, "{}", item),
            WeatherTextUnionReader::LongWeather(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<FixedWeather> for WeatherTextUnion {
    fn from(item: FixedWeather) -> Self {
        WeatherTextUnion::FixedWeather(item)
    }
}
impl ::core::convert::From<LongWeather> for WeatherTextUnion {
    fn from(item: LongWeather) -> Self {
        WeatherTextUnion::LongWeather(item)
    }
}
impl<'r> ::core::convert::From<FixedWeatherReader<'r>> for WeatherTextUnionReader<'r> {
    fn from(item: FixedWeatherReader<'r>) -> Self {
        WeatherTextUnionReader::FixedWeather(item)
    }
}
impl<'r> ::core::convert::From<LongWeatherReader<'r>> for WeatherTextUnionReader<'r> {
    fn from(item: LongWeatherReader<'r>) -> Self {
        WeatherTextUnionReader::LongWeather(item)
    }
}
impl WeatherTextUnion {
    pub const NAME: &'static str = "WeatherTextUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            WeatherTextUnion::FixedWeather(item) => item.as_bytes(),
            WeatherTextUnion::LongWeather(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            WeatherTextUnion::FixedWeather(item) => item.as_slice(),
            WeatherTextUnion::LongWeather(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            WeatherTextUnion::FixedWeather(_) => 0,
            WeatherTextUnion::LongWeather(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            WeatherTextUnion::FixedWeather(_) => "FixedWeather",
            WeatherTextUnion::LongWeather(_) => "LongWeather",
        }
    }
    pub fn as_reader<'r>(&'r self) -> WeatherTextUnionReader<'r> {
        match self {
            WeatherTextUnion::FixedWeather(item) => item.as_reader().into(),
            WeatherTextUnion::LongWeather(item) => item.as_reader().into(),
        }
    }
}
impl<'r> WeatherTextUnionReader<'r> {
    pub const NAME: &'r str = "WeatherTextUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            WeatherTextUnionReader::FixedWeather(item) => item.as_slice(),
            WeatherTextUnionReader::LongWeather(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            WeatherTextUnionReader::FixedWeather(_) => 0,
            WeatherTextUnionReader::LongWeather(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            WeatherTextUnionReader::FixedWeather(_) => "FixedWeather",
            WeatherTextUnionReader::LongWeather(_) => "LongWeather",
        }
    }
}
impl From<FixedWeather> for WeatherText {
    fn from(value: FixedWeather) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<LongWeather> for WeatherText {
    fn from(value: LongWeather) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct Weather(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Weather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Weather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Weather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Weather {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Weather::new_unchecked(v)
    }
}
impl Weather {
    const DEFAULT_VALUE: [u8; 5] = [0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> WeatherUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => WeatherType::new_unchecked(inner).into(),
            1 => WeatherText::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> WeatherReader<'r> {
        WeatherReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Weather {
    type Builder = WeatherBuilder;
    const NAME: &'static str = "Weather";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Weather(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct WeatherReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WeatherReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> WeatherReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> WeatherUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => WeatherTypeReader::new_unchecked(inner).into(),
            1 => WeatherTextReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WeatherReader<'r> {
    type Entity = Weather;
    const NAME: &'static str = "WeatherReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WeatherReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => WeatherTypeReader::verify(inner_slice, compatible),
            1 => WeatherTextReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WeatherBuilder(pub(crate) WeatherUnion);
impl WeatherBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<WeatherUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for WeatherBuilder {
    type Entity = Weather;
    const NAME: &'static str = "WeatherBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Weather::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum WeatherUnion {
    WeatherType(WeatherType),
    WeatherText(WeatherText),
}
#[derive(Debug, Clone, Copy)]
pub enum WeatherUnionReader<'r> {
    WeatherType(WeatherTypeReader<'r>),
    WeatherText(WeatherTextReader<'r>),
}
impl ::core::default::Default for WeatherUnion {
    fn default() -> Self {
        WeatherUnion::WeatherType(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for WeatherUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherUnion::WeatherType(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, WeatherType::NAME, item)
            }
            WeatherUnion::WeatherText(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, WeatherText::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for WeatherUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherUnionReader::WeatherType(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, WeatherType::NAME, item)
            }
            WeatherUnionReader::WeatherText(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, WeatherText::NAME, item)
            }
        }
    }
}
impl WeatherUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherUnion::WeatherType(ref item) => write!(f, "{}", item),
            WeatherUnion::WeatherText(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> WeatherUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WeatherUnionReader::WeatherType(ref item) => write!(f, "{}", item),
            WeatherUnionReader::WeatherText(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<WeatherType> for WeatherUnion {
    fn from(item: WeatherType) -> Self {
        WeatherUnion::WeatherType(item)
    }
}
impl ::core::convert::From<WeatherText> for WeatherUnion {
    fn from(item: WeatherText) -> Self {
        WeatherUnion::WeatherText(item)
    }
}
impl<'r> ::core::convert::From<WeatherTypeReader<'r>> for WeatherUnionReader<'r> {
    fn from(item: WeatherTypeReader<'r>) -> Self {
        WeatherUnionReader::WeatherType(item)
    }
}
impl<'r> ::core::convert::From<WeatherTextReader<'r>> for WeatherUnionReader<'r> {
    fn from(item: WeatherTextReader<'r>) -> Self {
        WeatherUnionReader::WeatherText(item)
    }
}
impl WeatherUnion {
    pub const NAME: &'static str = "WeatherUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            WeatherUnion::WeatherType(item) => item.as_bytes(),
            WeatherUnion::WeatherText(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            WeatherUnion::WeatherType(item) => item.as_slice(),
            WeatherUnion::WeatherText(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            WeatherUnion::WeatherType(_) => 0,
            WeatherUnion::WeatherText(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            WeatherUnion::WeatherType(_) => "WeatherType",
            WeatherUnion::WeatherText(_) => "WeatherText",
        }
    }
    pub fn as_reader<'r>(&'r self) -> WeatherUnionReader<'r> {
        match self {
            WeatherUnion::WeatherType(item) => item.as_reader().into(),
            WeatherUnion::WeatherText(item) => item.as_reader().into(),
        }
    }
}
impl<'r> WeatherUnionReader<'r> {
    pub const NAME: &'r str = "WeatherUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            WeatherUnionReader::WeatherType(item) => item.as_slice(),
            WeatherUnionReader::WeatherText(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            WeatherUnionReader::WeatherType(_) => 0,
            WeatherUnionReader::WeatherText(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            WeatherUnionReader::WeatherType(_) => "WeatherType",
            WeatherUnionReader::WeatherText(_) => "WeatherText",
        }
    }
}
impl From<WeatherType> for Weather {
    fn from(value: WeatherType) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<WeatherText> for Weather {
    fn from(value: WeatherText) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct WeatherOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for WeatherOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for WeatherOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for WeatherOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for WeatherOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        WeatherOpt::new_unchecked(v)
    }
}
impl WeatherOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Weather> {
        if self.is_none() {
            None
        } else {
            Some(Weather::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> WeatherOptReader<'r> {
        WeatherOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for WeatherOpt {
    type Builder = WeatherOptBuilder;
    const NAME: &'static str = "WeatherOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        WeatherOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        WeatherOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct WeatherOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for WeatherOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for WeatherOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for WeatherOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> WeatherOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<WeatherReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(WeatherReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for WeatherOptReader<'r> {
    type Entity = WeatherOpt;
    const NAME: &'static str = "WeatherOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        WeatherOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            WeatherReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct WeatherOptBuilder(pub(crate) Option<Weather>);
impl WeatherOptBuilder {
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Option<Weather>>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for WeatherOptBuilder {
    type Entity = WeatherOpt;
    const NAME: &'static str = "WeatherOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        WeatherOpt::new_unchecked(inner.into())
    }
}
impl From<Weather> for WeatherOpt {
    fn from(value: Weather) -> Self {
        Self::new_builder().set(Some(value)).build()
    }
}
#[derive(Clone)]
pub struct ShortTag(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ShortTag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ShortTag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ShortTag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for ShortTag {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        ShortTag::new_unchecked(v)
    }
}
impl ShortTag {
    const DEFAULT_VALUE: [u8; 12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> ShortTagReader<'r> {
        ShortTagReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ShortTag {
    type Builder = ShortTagBuilder;
    const NAME: &'static str = "ShortTag";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ShortTag(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShortTagReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ShortTagReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct ShortTagReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ShortTagReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ShortTagReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ShortTagReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> ShortTagReader<'r> {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for ShortTagReader<'r> {
    type Entity = ShortTag;
    const NAME: &'static str = "ShortTagReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ShortTagReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone)]
pub struct ShortTagBuilder(pub(crate) [Byte; 12]);
impl ::core::fmt::Debug for ShortTagBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for ShortTagBuilder {
    fn default() -> Self {
        ShortTagBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl ShortTagBuilder {
    pub const TOTAL_SIZE: usize = 12;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 12;
    pub fn set<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<[Byte; 12]>,
    {
        self.0 = v.into();
        self
    }
    pub fn nth0<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[0] = v.into();
        self
    }
    pub fn nth1<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[1] = v.into();
        self
    }
    pub fn nth2<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[2] = v.into();
        self
    }
    pub fn nth3<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[3] = v.into();
        self
    }
    pub fn nth4<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[4] = v.into();
        self
    }
    pub fn nth5<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[5] = v.into();
        self
    }
    pub fn nth6<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[6] = v.into();
        self
    }
    pub fn nth7<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[7] = v.into();
        self
    }
    pub fn nth8<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[8] = v.into();
        self
    }
    pub fn nth9<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[9] = v.into();
        self
    }
    pub fn nth10<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[10] = v.into();
        self
    }
    pub fn nth11<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0[11] = v.into();
        self
    }
}
impl molecule::prelude::Builder for ShortTagBuilder {
    type Entity = ShortTag;
    const NAME: &'static str = "ShortTagBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ShortTag::new_unchecked(inner.into())
    }
}
impl From<[Byte; 12usize]> for ShortTag {
    fn from(value: [Byte; 12usize]) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl ::core::convert::TryFrom<&[Byte]> for ShortTag {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[Byte]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(Self::new_builder()
            .set(<&[Byte; 12usize]>::try_from(value)?.clone())
            .build())
    }
}
impl From<ShortTag> for [Byte; 12usize] {
    #[track_caller]
    fn from(value: ShortTag) -> Self {
        [
            value.nth0(),
            value.nth1(),
            value.nth2(),
            value.nth3(),
            value.nth4(),
            value.nth5(),
            value.nth6(),
            value.nth7(),
            value.nth8(),
            value.nth9(),
            value.nth10(),
            value.nth11(),
        ]
    }
}
impl From<[u8; 12usize]> for ShortTag {
    fn from(value: [u8; 12usize]) -> Self {
        ShortTagReader::new_unchecked(&value).to_entity()
    }
}
impl ::core::convert::TryFrom<&[u8]> for ShortTag {
    type Error = ::core::array::TryFromSliceError;
    fn try_from(value: &[u8]) -> Result<Self, ::core::array::TryFromSliceError> {
        Ok(<[u8; 12usize]>::try_from(value)?.into())
    }
}
impl From<ShortTag> for [u8; 12usize] {
    #[track_caller]
    fn from(value: ShortTag) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<ShortTagReader<'a>> for &'a [u8; 12usize] {
    #[track_caller]
    fn from(value: ShortTagReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
impl<'a> From<&'a ShortTagReader<'a>> for &'a [u8; 12usize] {
    #[track_caller]
    fn from(value: &'a ShortTagReader<'a>) -> Self {
        ::core::convert::TryFrom::try_from(value.as_slice()).unwrap()
    }
}
#[derive(Clone)]
pub struct LongTag(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LongTag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LongTag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LongTag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for LongTag {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        LongTag::new_unchecked(v)
    }
}
impl LongTag {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> LongTagReader<'r> {
        LongTagReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LongTag {
    type Builder = LongTagBuilder;
    const NAME: &'static str = "LongTag";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LongTag(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongTagReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LongTagReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct LongTagReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LongTagReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LongTagReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LongTagReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> LongTagReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for LongTagReader<'r> {
    type Entity = LongTag;
    const NAME: &'static str = "LongTagReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LongTagReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct LongTagBuilder(pub(crate) Vec<Byte>);
impl LongTagBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0.push(v.into());
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        self.0.extend(iter);
        self
    }
    pub fn replace<T>(&mut self, index: usize, v: T) -> Option<Byte>
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v.into()))
    }
}
impl molecule::prelude::Builder for LongTagBuilder {
    type Entity = LongTag;
    const NAME: &'static str = "LongTagBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LongTag::new_unchecked(inner.into())
    }
}
pub struct LongTagIterator(LongTag, usize, usize);
impl ::core::iter::Iterator for LongTagIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for LongTagIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for LongTag {
    type Item = Byte;
    type IntoIter = LongTagIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        LongTagIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for LongTag {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl From<Vec<Byte>> for LongTag {
    fn from(v: Vec<Byte>) -> Self {
        Self::new_builder().set(v).build()
    }
}
impl ::core::iter::FromIterator<u8> for LongTag {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
impl From<Vec<u8>> for LongTag {
    fn from(v: Vec<u8>) -> Self {
        Self::new_builder()
            .set(v.into_iter().map(Into::into).collect())
            .build()
    }
}
#[derive(Clone)]
pub struct TagText(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TagText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TagText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TagText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for TagText {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TagText::new_unchecked(v)
    }
}
impl TagText {
    const DEFAULT_VALUE: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TagTextUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => ShortTag::new_unchecked(inner).into(),
            1 => LongTag::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> TagTextReader<'r> {
        TagTextReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TagText {
    type Builder = TagTextBuilder;
    const NAME: &'static str = "TagText";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TagText(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TagTextReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TagTextReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct TagTextReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TagTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TagTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TagTextReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> TagTextReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> TagTextUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => ShortTagReader::new_unchecked(inner).into(),
            1 => LongTagReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TagTextReader<'r> {
    type Entity = TagText;
    const NAME: &'static str = "TagTextReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TagTextReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => ShortTagReader::verify(inner_slice, compatible),
            1 => LongTagReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TagTextBuilder(pub(crate) TagTextUnion);
impl TagTextBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<TagTextUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for TagTextBuilder {
    type Entity = TagText;
    const NAME: &'static str = "TagTextBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TagText::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum TagTextUnion {
    ShortTag(ShortTag),
    LongTag(LongTag),
}
#[derive(Debug, Clone, Copy)]
pub enum TagTextUnionReader<'r> {
    ShortTag(ShortTagReader<'r>),
    LongTag(LongTagReader<'r>),
}
impl ::core::default::Default for TagTextUnion {
    fn default() -> Self {
        TagTextUnion::ShortTag(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for TagTextUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TagTextUnion::ShortTag(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ShortTag::NAME, item)
            }
            TagTextUnion::LongTag(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongTag::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for TagTextUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TagTextUnionReader::ShortTag(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ShortTag::NAME, item)
            }
            TagTextUnionReader::LongTag(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, LongTag::NAME, item)
            }
        }
    }
}
impl TagTextUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TagTextUnion::ShortTag(ref item) => write!(f, "{}", item),
            TagTextUnion::LongTag(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> TagTextUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            TagTextUnionReader::ShortTag(ref item) => write!(f, "{}", item),
            TagTextUnionReader::LongTag(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<ShortTag> for TagTextUnion {
    fn from(item: ShortTag) -> Self {
        TagTextUnion::ShortTag(item)
    }
}
impl ::core::convert::From<LongTag> for TagTextUnion {
    fn from(item: LongTag) -> Self {
        TagTextUnion::LongTag(item)
    }
}
impl<'r> ::core::convert::From<ShortTagReader<'r>> for TagTextUnionReader<'r> {
    fn from(item: ShortTagReader<'r>) -> Self {
        TagTextUnionReader::ShortTag(item)
    }
}
impl<'r> ::core::convert::From<LongTagReader<'r>> for TagTextUnionReader<'r> {
    fn from(item: LongTagReader<'r>) -> Self {
        TagTextUnionReader::LongTag(item)
    }
}
impl TagTextUnion {
    pub const NAME: &'static str = "TagTextUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            TagTextUnion::ShortTag(item) => item.as_bytes(),
            TagTextUnion::LongTag(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            TagTextUnion::ShortTag(item) => item.as_slice(),
            TagTextUnion::LongTag(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TagTextUnion::ShortTag(_) => 0,
            TagTextUnion::LongTag(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TagTextUnion::ShortTag(_) => "ShortTag",
            TagTextUnion::LongTag(_) => "LongTag",
        }
    }
    pub fn as_reader<'r>(&'r self) -> TagTextUnionReader<'r> {
        match self {
            TagTextUnion::ShortTag(item) => item.as_reader().into(),
            TagTextUnion::LongTag(item) => item.as_reader().into(),
        }
    }
}
impl<'r> TagTextUnionReader<'r> {
    pub const NAME: &'r str = "TagTextUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            TagTextUnionReader::ShortTag(item) => item.as_slice(),
            TagTextUnionReader::LongTag(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            TagTextUnionReader::ShortTag(_) => 0,
            TagTextUnionReader::LongTag(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            TagTextUnionReader::ShortTag(_) => "ShortTag",
            TagTextUnionReader::LongTag(_) => "LongTag",
        }
    }
}
impl From<ShortTag> for TagText {
    fn from(value: ShortTag) -> Self {
        Self::new_builder().set(value).build()
    }
}
impl From<LongTag> for TagText {
    fn from(value: LongTag) -> Self {
        Self::new_builder().set(value).build()
    }
}
#[derive(Clone)]
pub struct Tags(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Tags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Tags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Tags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Tags {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Tags::new_unchecked(v)
    }
}
impl Tags {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<TagText> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> TagText {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            TagText::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            TagText::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TagsReader<'r> {
        TagsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Tags {
    type Builder = TagsBuilder;
    const NAME: &'static str = "Tags";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Tags(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TagsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TagsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct TagsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TagsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TagsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TagsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> TagsReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<TagTextReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> TagTextReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            TagTextReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            TagTextReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TagsReader<'r> {
    type Entity = Tags;
    const NAME: &'static str = "TagsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TagsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            TagTextReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct TagsBuilder(pub(crate) Vec<TagText>);
impl TagsBuilder {
    pub fn set(mut self, v: Vec<TagText>) -> Self {
        self.0 = v;
        self
    }
    pub fn push<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<TagText>,
    {
        self.0.push(v.into());
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = TagText>>(mut self, iter: T) -> Self {
        self.0.extend(iter);
        self
    }
    pub fn replace<T>(&mut self, index: usize, v: T) -> Option<TagText>
    where
        T: ::core::convert::Into<TagText>,
    {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v.into()))
    }
}
impl molecule::prelude::Builder for TagsBuilder {
    type Entity = Tags;
    const NAME: &'static str = "TagsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Tags::new_unchecked(inner.into())
    }
}
pub struct TagsIterator(Tags, usize, usize);
impl ::core::iter::Iterator for TagsIterator {
    type Item = TagText;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for TagsIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Tags {
    type Item = TagText;
    type IntoIter = TagsIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        TagsIterator(self, 0, len)
    }
}
impl<'r> TagsReader<'r> {
    pub fn iter<'t>(&'t self) -> TagsReaderIterator<'t, 'r> {
        TagsReaderIterator(&self, 0, self.len())
    }
}
pub struct TagsReaderIterator<'t, 'r>(&'t TagsReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for TagsReaderIterator<'t, 'r> {
    type Item = TagTextReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for TagsReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<TagText> for Tags {
    fn from_iter<T: IntoIterator<Item = TagText>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl From<Vec<TagText>> for Tags {
    fn from(v: Vec<TagText>) -> Self {
        Self::new_builder().set(v).build()
    }
}
#[derive(Clone)]
pub struct Content(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Content {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Content {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Content {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Content {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Content::new_unchecked(v)
    }
}
impl Content {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Byte> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Byte {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.0.slice(molecule::NUMBER_SIZE..)
    }
    pub fn as_reader<'r>(&'r self) -> ContentReader<'r> {
        ContentReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Content {
    type Builder = ContentBuilder;
    const NAME: &'static str = "Content";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Content(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ContentReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ContentReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct ContentReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ContentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ContentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ContentReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> ContentReader<'r> {
    pub const ITEM_SIZE: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<ByteReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> ByteReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        &self.as_slice()[molecule::NUMBER_SIZE..]
    }
}
impl<'r> molecule::prelude::Reader<'r> for ContentReader<'r> {
    type Entity = Content;
    const NAME: &'static str = "ContentReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ContentReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct ContentBuilder(pub(crate) Vec<Byte>);
impl ContentBuilder {
    pub const ITEM_SIZE: usize = 1;
    pub fn set(mut self, v: Vec<Byte>) -> Self {
        self.0 = v;
        self
    }
    pub fn push<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0.push(v.into());
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Byte>>(mut self, iter: T) -> Self {
        self.0.extend(iter);
        self
    }
    pub fn replace<T>(&mut self, index: usize, v: T) -> Option<Byte>
    where
        T: ::core::convert::Into<Byte>,
    {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v.into()))
    }
}
impl molecule::prelude::Builder for ContentBuilder {
    type Entity = Content;
    const NAME: &'static str = "ContentBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Content::new_unchecked(inner.into())
    }
}
pub struct ContentIterator(Content, usize, usize);
impl ::core::iter::Iterator for ContentIterator {
    type Item = Byte;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for ContentIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Content {
    type Item = Byte;
    type IntoIter = ContentIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        ContentIterator(self, 0, len)
    }
}
impl ::core::iter::FromIterator<Byte> for Content {
    fn from_iter<T: IntoIterator<Item = Byte>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl From<Vec<Byte>> for Content {
    fn from(v: Vec<Byte>) -> Self {
        Self::new_builder().set(v).build()
    }
}
impl ::core::iter::FromIterator<u8> for Content {
    fn from_iter<T: IntoIterator<Item = u8>>(iter: T) -> Self {
        Self::new_builder()
            .extend(iter.into_iter().map(Into::into))
            .build()
    }
}
impl From<Vec<u8>> for Content {
    fn from(v: Vec<u8>) -> Self {
        Self::new_builder()
            .set(v.into_iter().map(Into::into).collect())
            .build()
    }
}
#[derive(Clone)]
pub struct DiaryItem(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for DiaryItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for DiaryItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for DiaryItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "content", self.content())?;
        write!(f, ", {}: {}", "date", self.date())?;
        write!(f, ", {}: {}", "date_raw", self.date_raw())?;
        write!(f, ", {}: {}", "weather", self.weather())?;
        write!(f, ", {}: {}", "title", self.title())?;
        write!(f, ", {}: {}", "tags", self.tags())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for DiaryItem {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        DiaryItem::new_unchecked(v)
    }
}
impl DiaryItem {
    const DEFAULT_VALUE: [u8; 40] = [
        40, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 36, 0, 0, 0, 36, 0, 0, 0, 36, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn content(&self) -> Content {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Content::new_unchecked(self.0.slice(start..end))
    }
    pub fn date(&self) -> DateInt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        DateInt::new_unchecked(self.0.slice(start..end))
    }
    pub fn date_raw(&self) -> DateRawOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DateRawOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn weather(&self) -> WeatherOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        WeatherOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn title(&self) -> TitleOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        TitleOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn tags(&self) -> Tags {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Tags::new_unchecked(self.0.slice(start..end))
        } else {
            Tags::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> DiaryItemReader<'r> {
        DiaryItemReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for DiaryItem {
    type Builder = DiaryItemBuilder;
    const NAME: &'static str = "DiaryItem";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DiaryItem(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiaryItemReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiaryItemReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .content(self.content())
            .date(self.date())
            .date_raw(self.date_raw())
            .weather(self.weather())
            .title(self.title())
            .tags(self.tags())
    }
}
#[derive(Clone, Copy)]
pub struct DiaryItemReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DiaryItemReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DiaryItemReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DiaryItemReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "content", self.content())?;
        write!(f, ", {}: {}", "date", self.date())?;
        write!(f, ", {}: {}", "date_raw", self.date_raw())?;
        write!(f, ", {}: {}", "weather", self.weather())?;
        write!(f, ", {}: {}", "title", self.title())?;
        write!(f, ", {}: {}", "tags", self.tags())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> DiaryItemReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn content(&self) -> ContentReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ContentReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn date(&self) -> DateIntReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        DateIntReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn date_raw(&self) -> DateRawOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        DateRawOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn weather(&self) -> WeatherOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        WeatherOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn title(&self) -> TitleOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        TitleOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tags(&self) -> TagsReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            TagsReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TagsReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DiaryItemReader<'r> {
    type Entity = DiaryItem;
    const NAME: &'static str = "DiaryItemReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DiaryItemReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ContentReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        DateIntReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        DateRawOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        WeatherOptReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        TitleOptReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        TagsReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct DiaryItemBuilder {
    pub(crate) content: Content,
    pub(crate) date: DateInt,
    pub(crate) date_raw: DateRawOpt,
    pub(crate) weather: WeatherOpt,
    pub(crate) title: TitleOpt,
    pub(crate) tags: Tags,
}
impl DiaryItemBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn content<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Content>,
    {
        self.content = v.into();
        self
    }
    pub fn date<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<DateInt>,
    {
        self.date = v.into();
        self
    }
    pub fn date_raw<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<DateRawOpt>,
    {
        self.date_raw = v.into();
        self
    }
    pub fn weather<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<WeatherOpt>,
    {
        self.weather = v.into();
        self
    }
    pub fn title<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<TitleOpt>,
    {
        self.title = v.into();
        self
    }
    pub fn tags<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<Tags>,
    {
        self.tags = v.into();
        self
    }
}
impl molecule::prelude::Builder for DiaryItemBuilder {
    type Entity = DiaryItem;
    const NAME: &'static str = "DiaryItemBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.content.as_slice().len()
            + self.date.as_slice().len()
            + self.date_raw.as_slice().len()
            + self.weather.as_slice().len()
            + self.title.as_slice().len()
            + self.tags.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.content.as_slice().len();
        offsets.push(total_size);
        total_size += self.date.as_slice().len();
        offsets.push(total_size);
        total_size += self.date_raw.as_slice().len();
        offsets.push(total_size);
        total_size += self.weather.as_slice().len();
        offsets.push(total_size);
        total_size += self.title.as_slice().len();
        offsets.push(total_size);
        total_size += self.tags.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.content.as_slice())?;
        writer.write_all(self.date.as_slice())?;
        writer.write_all(self.date_raw.as_slice())?;
        writer.write_all(self.weather.as_slice())?;
        writer.write_all(self.title.as_slice())?;
        writer.write_all(self.tags.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        DiaryItem::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct DiaryItems(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for DiaryItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for DiaryItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for DiaryItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for DiaryItems {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        DiaryItems::new_unchecked(v)
    }
}
impl DiaryItems {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<DiaryItem> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> DiaryItem {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            DiaryItem::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            DiaryItem::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> DiaryItemsReader<'r> {
        DiaryItemsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for DiaryItems {
    type Builder = DiaryItemsBuilder;
    const NAME: &'static str = "DiaryItems";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        DiaryItems(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiaryItemsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DiaryItemsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct DiaryItemsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DiaryItemsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DiaryItemsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DiaryItemsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> DiaryItemsReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<DiaryItemReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> DiaryItemReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            DiaryItemReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            DiaryItemReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DiaryItemsReader<'r> {
    type Entity = DiaryItems;
    const NAME: &'static str = "DiaryItemsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DiaryItemsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            DiaryItemReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct DiaryItemsBuilder(pub(crate) Vec<DiaryItem>);
impl DiaryItemsBuilder {
    pub fn set(mut self, v: Vec<DiaryItem>) -> Self {
        self.0 = v;
        self
    }
    pub fn push<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<DiaryItem>,
    {
        self.0.push(v.into());
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = DiaryItem>>(mut self, iter: T) -> Self {
        self.0.extend(iter);
        self
    }
    pub fn replace<T>(&mut self, index: usize, v: T) -> Option<DiaryItem>
    where
        T: ::core::convert::Into<DiaryItem>,
    {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v.into()))
    }
}
impl molecule::prelude::Builder for DiaryItemsBuilder {
    type Entity = DiaryItems;
    const NAME: &'static str = "DiaryItemsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        DiaryItems::new_unchecked(inner.into())
    }
}
pub struct DiaryItemsIterator(DiaryItems, usize, usize);
impl ::core::iter::Iterator for DiaryItemsIterator {
    type Item = DiaryItem;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for DiaryItemsIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for DiaryItems {
    type Item = DiaryItem;
    type IntoIter = DiaryItemsIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        DiaryItemsIterator(self, 0, len)
    }
}
impl<'r> DiaryItemsReader<'r> {
    pub fn iter<'t>(&'t self) -> DiaryItemsReaderIterator<'t, 'r> {
        DiaryItemsReaderIterator(&self, 0, self.len())
    }
}
pub struct DiaryItemsReaderIterator<'t, 'r>(&'t DiaryItemsReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for DiaryItemsReaderIterator<'t, 'r> {
    type Item = DiaryItemReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for DiaryItemsReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::FromIterator<DiaryItem> for DiaryItems {
    fn from_iter<T: IntoIterator<Item = DiaryItem>>(iter: T) -> Self {
        Self::new_builder().extend(iter).build()
    }
}
impl From<Vec<DiaryItem>> for DiaryItems {
    fn from(v: Vec<DiaryItem>) -> Self {
        Self::new_builder().set(v).build()
    }
}
#[derive(Clone)]
pub struct CommonDiary(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CommonDiary {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CommonDiary {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CommonDiary {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "author", self.author())?;
        write!(f, ", {}: {}", "items", self.items())?;
        write!(f, ", {}: {}", "title", self.title())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CommonDiary {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CommonDiary::new_unchecked(v)
    }
}
impl CommonDiary {
    const DEFAULT_VALUE: [u8; 38] = [
        38, 0, 0, 0, 16, 0, 0, 0, 34, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn author(&self) -> AuthorName {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        AuthorName::new_unchecked(self.0.slice(start..end))
    }
    pub fn items(&self) -> DiaryItems {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        DiaryItems::new_unchecked(self.0.slice(start..end))
    }
    pub fn title(&self) -> TitleOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            TitleOpt::new_unchecked(self.0.slice(start..end))
        } else {
            TitleOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CommonDiaryReader<'r> {
        CommonDiaryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CommonDiary {
    type Builder = CommonDiaryBuilder;
    const NAME: &'static str = "CommonDiary";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CommonDiary(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommonDiaryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CommonDiaryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .author(self.author())
            .items(self.items())
            .title(self.title())
    }
}
#[derive(Clone, Copy)]
pub struct CommonDiaryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CommonDiaryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CommonDiaryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CommonDiaryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "author", self.author())?;
        write!(f, ", {}: {}", "items", self.items())?;
        write!(f, ", {}: {}", "title", self.title())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CommonDiaryReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn author(&self) -> AuthorNameReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        AuthorNameReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn items(&self) -> DiaryItemsReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        DiaryItemsReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn title(&self) -> TitleOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            TitleOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TitleOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CommonDiaryReader<'r> {
    type Entity = CommonDiary;
    const NAME: &'static str = "CommonDiaryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CommonDiaryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        AuthorNameReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        DiaryItemsReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        TitleOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Clone, Debug, Default)]
pub struct CommonDiaryBuilder {
    pub(crate) author: AuthorName,
    pub(crate) items: DiaryItems,
    pub(crate) title: TitleOpt,
}
impl CommonDiaryBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn author<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<AuthorName>,
    {
        self.author = v.into();
        self
    }
    pub fn items<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<DiaryItems>,
    {
        self.items = v.into();
        self
    }
    pub fn title<T>(mut self, v: T) -> Self
    where
        T: ::core::convert::Into<TitleOpt>,
    {
        self.title = v.into();
        self
    }
}
impl molecule::prelude::Builder for CommonDiaryBuilder {
    type Entity = CommonDiary;
    const NAME: &'static str = "CommonDiaryBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.author.as_slice().len()
            + self.items.as_slice().len()
            + self.title.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.author.as_slice().len();
        offsets.push(total_size);
        total_size += self.items.as_slice().len();
        offsets.push(total_size);
        total_size += self.title.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.author.as_slice())?;
        writer.write_all(self.items.as_slice())?;
        writer.write_all(self.title.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CommonDiary::new_unchecked(inner.into())
    }
}
